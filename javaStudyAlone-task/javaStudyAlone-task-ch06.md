## 06-1 객체 지향 프로그래밍

- **클래스**: 객체를 만들기 위한 설계도
- **객체**: 클래스로부터 생성되는 요소. `new 클래스()`로 생성할 수 있다.
- **new 연산자**: 객체 생성 연산자. 생성자를 호출하고 객체 생성 번지를 리턴
- **클래스 변수**: 클래스로 선언한 변수. 해당 클래스이 객체 번지가 저장된다.
- **인스턴스**: 객체는 클래스의 인스턴스이다.
- **클래스 멤버**: 클래스에 선언되는 멤버는 필드·생성자·메소드가 있다.

### 확인 문제 및 풀이

1. 클래스는 객체를 생성하기 위한 설계도와 같은 것이다. new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성되며, 객체는 클래스의 인스턴스이다.

   1-3. **하나의 클래스로 여러 객체를 생성**할 수 있다.

2. - 메소드: 객체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다.
   - 필드: 객체의 데이터를 저장한다.
   - 생성자: 객체의 초기화를 담당한다.
3. - `String name;`: 필드
   - `Member(String name) {}`: 생성자
   - `void setName(String name) {}`: 메소드

## 06-2 필드

- **필드 선언**: 클래스 중괄호 {} 블록 어디서든 선언하나, 생성자와 메소드 내부에서는 선언할 수 없다.
- **필드 사용**: 클래스 내부의 생성자와 메소드에서 바로 사용 가능. 클래스 외부에서 사용할 시 반드시 객체를 생성하고 참조 변수를 거쳐야 한다.

### 확인 문제 및 풀이

1. 필드는 메소드에서 사용할 수 있다. 필드는 클래스 블록 어디서든 선언할 수 있다. (생성자, 메소드 내부 제외) 그리고 필드는 초기값을 주지 않더라도 기본값으로 자동 초기화된다.

   1-3. 필드는 **객체 외부에서 접근할 수 있다.**

2.

```
public class Member {
	String name;
	String id;
	String password;
	int age;
}
```

3. `new Member()`, `member.name`, `member.age`

## 06-3 생성자

- **기본 생성자**: 클래스 선언 시 컴파일러에 의해 자동으로 추가되는 생성자
- **생성자 선언**: 클래스로부터 객체를 생성할 때 호출되는 생성자를 명시적으로 선언할 수 있다. 생성자를 선언 시 기본 생성자는 생성되지 않는다.
- **매개 변수**: 생성자 호출 시 값을 전달받기 위해 선언되는 변수
- **객체 초기화**: 객체를 사용하기 전에 준비하는 과정으로 필드를 선언 시 초기화하거나 생성자 내부에서 필드값을 초기화할 수 있으며, 메소드를 호출하는 내용으로 구성된다.
- **오버로딩**: 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
- **`this()`**: 객체 자신의 또 다른 생성자를 호출할 때 사용

### 확인 문제 및 풀이

1. 생성자는 다른 생성자를 호출하기 위해 `this()`를 사용할 수 있다. 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다. 매개 변수의 수·타입·순서가 다른 생성자를 여러 개 선언할 수 있다.

   1-1. 객체를 생성하려면 **생성자 호출이 반드시 필요하다.**

2.

```
public class Member {
	String name;
	String id;
	String password;
	int age;
}
```

3.

```
Board(String title, String content) {
	this(title, content, "로그인한 회원아이디", "현재 컴퓨터 날짜", 0);
}

Board(String title, String content, String writer) {
	this(title, content, writer, "현재 컴퓨터 날짜", 0);
}

Board(String title, String content, String writer, String date) {
	this(title, content, writer, date, 0);
}
```

4.

```
Board board1 = new Board("제목", "내용");
Board board2 = new Board("제목", "내용", "홍길동");
Board board3 = new Board("제목", "내용", "홍길동", "2025-12-31");
Board board4 = new Board("제목", "내용", "홍길동", "2025-12-31", 0);
```

## 06-4 메소드

- **선언부**: 메소드 선언부는 리턴 타입·메소드 이름·매개 변수 선언 부분을 뜻함
- **void**: 리턴값이 없는 메소드는 리턴 타입으로 void를 기술해야 함
- **매개 변수**: 메소드 호출 시 제공되는 매개값은 메소드 선언부의 매개 변수에 차례대로 대입, 메소드 블록 실행 시 이용된다.
- **return문**: 메소드 선언부에 리턴 타입이 있다면 리턴값을 지정하기 위해 return문이 반드시 필요하다. 리턴 타입이 void라면 return문은 필요 없으나, 메소드 실행 종료를 위해 사용할 수도 있다.
- **호출**: 메소드를 실행하려면 `메소드 이름 (매개값, ...)` 형태로 호출해야 함
- **오버로딩**: 클래스 내에 같은 이름의 메소드를 여러 개 선언할 경우 ** 메소드 오버로딩(Overloading) **이라고 한다. 메소드 오버로딩의 조건은 매개 변수의 타입·개수·순서 중 하나가 달라야한다.

### 확인 문제 및 풀이

1.  메소드에 대해서

    1-1. 리턴 값이 없는 메소드는 리턴 타입을 **void**로 해야 한다.

    1-2. 리턴 타입이 있는 메소드는 리턴 값을 지정하기 위해 반드시 **return문**이 있어야 한다.

    1-3. 매개값의 개수를 모를 경우 ** ... **를 이용해서 매개 변수를 선언할 수 있다.

    1-4. 같은 이름의 메소드를 여러 개 선언하는 것을 **메소드 오버로딩**이라고 한다.

2.  메소드 오버로딩이란 동일한 이름의 메소드를 여러 개 선언하는 것을 말하며, 매개 변수의 타입·개수·순서를 다르게 선언해야 한다. 매개값의 타입 및 개수에 따라 호출될 메소드가 선택된다.

    2-2. 반드시 리턴 타입이 다를 필요는 없다.

3.

```
public class MemberService {
	boolean login(String id, String password) {
		if(id.equals("hong") && password.equals("12345")) {
			return true;
		} else {
			return false;
		}
	}

	void logout(String id) {
		System.out.println("로그아웃 되었습니다.");
	}
}
```

4.

```
public class Printer {
	static void println(int value) {
		System.out.println(value);
	}

	static void println(boolean value) {
		System.out.println(value);
	}

	static void println(double value) {
		System.out.println(value);
	}

	static void println(String value) {
		System.out.println(value);
	}
}
```

## 06-5 인스턴스 멤버와 정적 멤버

- **인스턴스(instance) 멤버**: 객체(인스턴스)를 생성한 후 사용할 수 있는 필드 및 메소드. 각각 인스턴스 필드·인스턴스 메소드라고 불린다.
- **this**: 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다. (예: `this.model`의 경우 자신이 가지고 있는 model 필드임) this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.
- **정적 멤버**: 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드. 각각 정적 필드·정적 메소드라고 불린다.
- **static**: 정적 멤버를 선언할 때 사용하는 키워드
- **싱글톤**: 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야하는 경우가 있는데, 단 하나만 생성된다고 하여 해당 객체를 싱글톤(Singleton)이라 불린다.
- **final 필드**: 초기값이 저장되면 해당 값이 최종적인 값이 되어 프로그램 실행 도중에 수정할 수 없는 필드. `final` 키워드로 선언한다.
- **상수**: 수학에서 사용되는 원주율 파이(π)나 지구의 무게 및 둘레 같은 불변의 값을 저장하는 필드를 Java에서는 상수(constant)라 불린다. `final static` 키워드로 선언한다.

### 확인 문제 및 풀이

1. 정적 멤버는 static으로 선언된 필드와 메소드를 말한다. 정적 필드와 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있으며, 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다.

   1-2. 인스턴스 필드는 생성자에서 초기화할 수 있다.

2. final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없으며, 상수의 이름은 대문자로 작성하는 것이 관례이다. 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.

   2-2. final 필드와 상수는 생성자에서 초기화할 수 있다.

3.

```
public class ShopService {
	private static ShopService singleton = new ShopService();

	private ShopService() {}

	static ShopService getInstance() {
		return singleton;
	}
}
```

## 06-6 패캐지와 접근 제한자

- **패키지 선언**: 해당 클래스 또는 인터페이스가 어떤 패키지에 속할 것인지를 선언하는 것. 소스 파일의 최상단에 위치한다. (예: `package 상위패키지.하위패키지;`)
- **import문**: 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어있을 경우, import문으로 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려야 한다. (예: `import 상위패키지.하위패키지.클래스이름; import 상위패키지.하위패키지.*;`)
- **접근 제한자**: 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있다. 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나, 필드나 메소드를 사용하지 못하게 막아야 하는 경우도 있다. 이때 접근 제한자를 사용할 수 있다.

### 접근 제한의 종류와 적용할 대상

| 접근 제한 | 적용 대상                    | 접근할 수 없는 클래스                          |
| --------- | ---------------------------- | ---------------------------------------------- |
| public    | 클래스, 필드, 생성자, 메소드 | 없음                                           |
| protected | 필드, 생성자, 메소드         | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default   | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스                    |
| private   | 필드, 생성자, 메소드         | 모든 외부 클래스                               |

- **Getter/Setter**: 필드는 외부에서 접근할 수 없도록 막고, 메소드는 공개해서 외부로부터 메소드를 통해 필드에 접근하도록 유도한다. 필드의 값을 외부로 리턴해주는 메소드를 Getter, 외부에서 값을 받아 필드로 변경하는 메소드를 Setter라고 불린다.

### 확인 문제 및 풀이

1. 접근 제한자는 클래스·필드·생성자·메소드의 사용을 제한한다. public 접근 제한은 아무런 제한 없이 해당 요소를 사용할 수 있게 한다. 외부에서 접근하지 못하도록 하려면 private 접근 제한을 해야 한다.

   1-3. default 접근 제한은 **같은 패키지에서만 사용을 허가**한다.
